#!/usr/bin/ruby

# ======================================================================
# 
# Configuring Textplay
# ====================
# 
# Using Fountain's `key:value` title-page syntax, you can control how
# textplay interperets your screenplay. The following values can
# be customized:
# 
#     * goldman_sluglines -- default: ON
# 
#       By defualt textplay interprets any line that's all-caps as a
#       slugline.
# 
#     * screenbundle_comments -- default: ON
# 
#       To provide backwards-compatibility with screenbundle documents,
#       textplay interprets any line starting with 2 slahes `//` as comments.
# 
#     * font -- default: "Courier Prime"
# 
#       By default textplay uses "Courier Prime" <http://quoteunquoteapps.com/courierprime/>
#       a great alternative font for screenwriters. If you don't have that
#       installed plain Courier will be used.
#   
#       If you'd like to specify your own font, Courier Prime and Courier
#       will be used as backup fonts.
# 
#     * title (for metadata only) -- default: "A Screenplay"
# 
#       You can define what name textplay uses when generating files.
# 
#     * slugline_spacing -- default: 1
# 
#       By default textplay puts a single empty line above sluglines, you
#       can change this to any number you want.
# 
#     * bold_sluglines -- default: ON
#     * underlined_sluglines -- default: OFF
# 
#     * header -- empty by default
# 
#       Header information is displayed on every page, use this for
#       revision numbers, dates, etc.
# 
#     * footer -- empty by default
# 
#       Any information you'd like in the footer of every page can go here.
# 
# 
# For the time being, all other key/values are preserved as meta-data in
# the document, but otherwise ignored.
# 
# 
# 
# To set these values just define the key/values at the beginning of the
# document like this:
# 
# title: Ron's Woodland Adventure
# font: Courier New
# goldman_sluglines: off
# bold_sluglines: on
# 
# For more details see the Fountain documentation 
# <http://fountain.io/syntax#section-titlepage>.
# 
# It's worth noting a few things:
# 
# 1. These key:value pairs must be the first (non-comment) thing in
#    the document.
# 2. Only one blank line is allowed between key:value pairs, two empty
#    lines will stop textplay from continuing to parse the document for
#    options.
#
# ======================================================================

# read the input
# text = ARGF.read

# define test text
text = '
# First line - not tag

Title:
    _**BRICK & STEEL**_
    _**FULL RETIRED**_
Credit: Written by
Author: Stu Maschwitz
Source: Story by KTM
Draft date: 1/20/2012
Contact:
    Next Level Productions
    1588 Mission Dr.
    Solvang, CA 93463

Last line - not tag
'

# -------------------------

# define regex for key-value pairs

multi_key = /
  # Cannot begin with spaces (that's a value)
  ^(?!\ )
  # the key itself
  [\S\ ]+:\ *\n
  # the indented value - multiple lines allowed
  ((\ {3,}|\t).+\n?)+
  # a single empty line is allowed - 2 empty lines ends the meta_block
  (^\ *\n){0,1}
/x

single_key = /
  # Cannot begin with spaces (that's a value)
  ^(?!\ )
  # the key
  ([\S\ ]+):\ 
  # the value
  ([^\n]+)\n
  # a single empty line is allowed - 2 empty lines ends the meta_block
  (^\ *\n){0,1}
/x

# -------------------------

# If the first thing in the document (aside from comments) is a
# key-value pair, then enable tagging of the meta block

# returns the fist non-comment line
l1_test = /^(?! *(#|=|\|\[\[|\/\*)).+/.match(text)
# convert match to string
l1_test = l1_test[0]

# if the first line contains a colon and an optional space, set the
# "meta" variable
if l1_test =~ /: */
  meta = true
else
  meta = false
end

# -------------------------

# debugging switches

debug = false

# -------------------------

# If the first (non-comment) line looks like a meta tag...
# then assume everything that follows is a block of meta tags

if meta == true

  # Find the FIRST occurance of what looks like a meta_block and tag it.
  # Very important that this is "sub" and not "gsub" - gsub will match
  # everything in the document that looks like meta tags - not a
  # great idea.
  text = text.sub(/(#{multi_key}|#{single_key})+/,'<meta_block>'+"\n"+'\0'+'</meta_block>'+"\n\n")

  # Identify multi-line key-value pairs...

    # search for multi-line key-value pairs - and tag with markup
    text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/){|tags|
      tags.gsub(/#{multi_key}/, '<meta_multi>'+"\n"+'\0'+"\n"+'</meta_multi>'+"\n")
    }

    # search inside meta for keys
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/(.+): */, '<key>\1</key>')
    }

    # search inside meta-tags for values
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/( {3,}|\t)(.+)/, '<value>\2</value>')
    }

    # clean-up multi-line values
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/<\/value>\n<value>/, "\n")
    }

    # remove empty lines
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/^\n/, "")
    }

  # Identify single-line key-value pairs

  text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/){|tags|
      tags.gsub(/#{single_key}/, '<meta-single><key>\1</key><value>\2</value></meta-single>'+"\n")
    }

  if debug == true
    print text
  end

else
  # if there's no meta info, just print the text
  print text
end


# -------------------------

if meta == true

  # This sets the value of variables based on the meta tags

  # title
  title = text.scan(/<key>title<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # goldman_sluglines
  goldman_sluglines = text.scan(/<key>goldman_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # screenbundle_comments
  screenbundle_comments = text.scan(/<key>screenbundle_comments<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # font
  font = text.scan(/<key>font<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # slugline_spacing
  slugline_spacing = text.scan(/<key>slugline_spacing<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # bold_sluglines
  bold_sluglines = text.scan(/<key>bold_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # underlined_sluglines
  underlined_sluglines = text.scan(/<key>underlined_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # header
  header = text.scan(/<key>header<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # footer
  footer = text.scan(/<key>footer<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  p title
  p goldman_sluglines
  p screenbundle_comments
  p font
  p slugline_spacing
  p bold_sluglines
  p underlined_sluglines
  p header
  p footer

end

