#!/usr/bin/env ruby

require 'optparse'
require 'fcntl'

# ---------- OPTIONS ---------- #

# Setup the options parser
options = {}
optparse = OptionParser.new do|opts|

    # This is the help banner, which just explains the command syntax
    opts.banner = "
    Usage: textplay_tags [options] [input-path]

    • The first argument is always an input-path.
    • If there's no input-path textplay reads from STDIN.

    Options:
    "
    # Define options
    options[:about] = false
    opts.on( '-a', '--about', "Display the about text" ) do
        options[:about] = true
    end

end  #optparse

# Parse the options and remove them from ARGV
optparse.parse!

about_text = "
NAME
    textplay-tags - codetags for textplay screenplays

SYNOPSIS
    textplay_tags [options] [<file.fountain>]

DESCRIPTION
    Textplay tags scans your fountain-formatted screenplays for things
    very similar to \"codetags\" (http://www.python.org/dev/peps/pep-0350/).
    
    By including these tags in your document you can use this script to
    quickly compile a to-do list directly from your inline notes.

USAGE
    The following command displays all tags within a file called \"file.fountain\"
    $ textplay_tags file.fountain
    
TAG FORMAT
    Syntax:
    
    1. textplay_tags will only look for tags within textplay-formatted comments.
    2. One codetag per line, nothing else on the line, indentation allowed

    The following tags are supported:
    * todo
    * fixme
    * note
     
    Examples:

    [[todo: this is a todo]]

    // fixme: this is something to fix

    /* ============
       tags can also go in multi-line comments, like this:
       note: remove all the dialogue from this scene
       only the 2nd line is a tag
    ============ */
"

# ---------- INPUT / OUTPUT ---------- #

# if there's an argument, assume it's a file
if ARGV[0]
    text = File.read(ARGV[0], :encoding => "UTF-8")
    
# if there's no argument, assume the input is in STDIN
else

  # check to see if anything is in SDTIN
  if STDIN.fcntl(Fcntl::F_GETFL, 0) == 0
    # if so, read it
    text = STDIN.read 
  else
    # if nothing is check for --about and send about text to less
    if options[:about] == true
      IO.popen("less", "w") { |f| f.puts about_text }
    else
      # otherwise display the option banner
      puts optparse
    end
    exit(-1)
  end

end

# ---------- PROCESS DOCUMENT ---------- #

# Search for comments and tag them
text = text.gsub(/

# Boneyard comments
\/\*(.|\n)+?\*\/         |
# Fountain notes
\[{2}[^\]]+\]{2}         |
# Screenbundle comments
^[ \t]*\/\/\s?(.*)$      |
# Fountain sections synopsis
^[ \t]*(\#+|\=+)\ (.*)$


/x, '<comment>'+"\n"+'\0'+"\n"+'</comment>')

# Search inside comments for codetags and mark them inline
text = text.gsub(/<comment>(.|\n)+?<\/comment>/x){|tag|
  tag.gsub(/(todo|fixme|note): (.+?)(?=\n| \*\/| ?\]{2})/i, '<tag>\0</tag>')
}

# ---------- PRINT MATCHING LINES ---------- #

text.lines.grep(/<tag>(.+?)<\/tag>/){|x|
    puts "#{text.lines.find_index(x)+1}: #{$1}"
}